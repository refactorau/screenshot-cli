import PDFDocument from 'pdfkit';
import fs from 'fs';
import { DataFile } from './types';

export class PDFGenerator {
  private doc: InstanceType<typeof PDFDocument>;
  private currentY: number = 0;
  private pageWidth: number = 841.89; // A4 landscape width in points
  private pageHeight: number = 595.28; // A4 landscape height in points
  private margin: number = 40;
  private contentWidth: number;
  private imageWidth: number;
  private imageHeight: number;

  constructor() {
    this.doc = new PDFDocument({
      size: 'A4',
      layout: 'landscape',
      margins: {
        top: this.margin,
        bottom: this.margin,
        left: this.margin,
        right: this.margin
      }
    });

    this.contentWidth = this.pageWidth - (this.margin * 2);
    this.imageWidth = (this.contentWidth - 20) / 2; // Space for two images side by side with gap
    this.imageHeight = 350; // Increased height for landscape format
  }

  async generateReport(dataFile: DataFile, outputPath: string): Promise<void> {
    try {
      // Set up the PDF output stream
      const stream = fs.createWriteStream(outputPath);
      this.doc.pipe(stream);

      // Add title page
      this.addTitlePage(dataFile);

      // Add screenshot pages
      await this.addScreenshotPages(dataFile);

      // Add summary page
      this.addSummaryPage(dataFile);

      // Finalize the PDF
      this.doc.end();

      // Wait for the stream to finish
      await new Promise<void>((resolve, reject) => {
        stream.on('finish', () => resolve());
        stream.on('error', reject);
      });

    } catch (error) {
      throw new Error(`Failed to generate PDF: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private addTitlePage(dataFile: DataFile): void {
    // Set dark background matching GitHub's dark theme
    this.doc.rect(0, 0, this.pageWidth, this.pageHeight)
      .fill('#0d1117');

    // Add title with GitHub-style colors
    this.doc.fillColor('#f0f6fc')
      .fontSize(36)
      .font('Helvetica-Bold')
      .text('Screenshot Report', this.margin, 160, { align: 'center' });

    // Add subtitle
    const modeText = dataFile.metadata.mode === 'single' ? 'Single Screenshot Mode' : 'Before/After Comparison';
    this.doc.fontSize(20)
      .fillColor('#58a6ff')
      .font('Helvetica')
      .text(modeText, this.margin, 210, { align: 'center' });

    // Add generation info with better styling
    const generatedDate = new Date(dataFile.metadata.generatedAt).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });

    this.doc.fontSize(14)
      .fillColor('#8b949e')
      .text(`Generated: ${generatedDate}`, this.margin, 260, { align: 'center' });

    // Add statistics with cards-like styling
    const statsY = 330;
    const cardWidth = 150;
    const cardHeight = 80;
    const cardSpacing = 40;
    const totalCardsWidth = (cardWidth * 3) + (cardSpacing * 2);
    const cardsStartX = (this.pageWidth - totalCardsWidth) / 2;

    // Total URLs card
    this.doc.rect(cardsStartX, statsY, cardWidth, cardHeight)
      .fill('#21262d')
      .stroke('#30363d');

    this.doc.fillColor('#58a6ff')
      .fontSize(24)
      .font('Helvetica-Bold')
      .text(dataFile.metadata.totalUrls.toString(), cardsStartX, statsY + 15, { width: cardWidth, align: 'center' });

    this.doc.fillColor('#8b949e')
      .fontSize(12)
      .font('Helvetica')
      .text('Total URLs', cardsStartX, statsY + 45, { width: cardWidth, align: 'center' });

    // Successful card
    const successX = cardsStartX + cardWidth + cardSpacing;
    this.doc.rect(successX, statsY, cardWidth, cardHeight)
      .fill('#21262d')
      .stroke('#30363d');

    this.doc.fillColor('#3fb950')
      .fontSize(24)
      .font('Helvetica-Bold')
      .text(dataFile.metadata.successCount.toString(), successX, statsY + 15, { width: cardWidth, align: 'center' });

    this.doc.fillColor('#8b949e')
      .fontSize(12)
      .font('Helvetica')
      .text('Successful', successX, statsY + 45, { width: cardWidth, align: 'center' });

    // Failed card
    const failedX = successX + cardWidth + cardSpacing;
    this.doc.rect(failedX, statsY, cardWidth, cardHeight)
      .fill('#21262d')
      .stroke('#30363d');

    this.doc.fillColor('#f85149')
      .fontSize(24)
      .font('Helvetica-Bold')
      .text(dataFile.metadata.errorCount.toString(), failedX, statsY + 15, { width: cardWidth, align: 'center' });

    this.doc.fillColor('#8b949e')
      .fontSize(12)
      .font('Helvetica')
      .text('Failed', failedX, statsY + 45, { width: cardWidth, align: 'center' });

    // Add footer
    this.doc.fontSize(12)
      .fillColor('#6e7681')
      .text('Generated by Screenshot CLI', 0, 480, {
        width: this.pageWidth,
        align: 'center'
      });
  }



  private async addScreenshotPages(dataFile: DataFile): Promise<void> {
    const successfulResults = dataFile.results.filter(r => r.success);

    for (const result of successfulResults) {
      this.doc.addPage();

      // Dark background
      this.doc.rect(0, 0, this.pageWidth, this.pageHeight)
        .fill('#0d1117');

      // Add header section with subtle background
      this.doc.rect(0, 0, this.pageWidth, 120)
        .fill('#161b22');

      // Add URL header with better styling
      this.doc.fillColor('#f0f6fc')
        .fontSize(16)
        .font('Helvetica-Bold')
        .text(result.url, this.margin, 40, {
          width: this.contentWidth,
          ellipsis: true
        });

      // Add timestamp with better styling
      const timestamp = result.timestamp || result.beforeTimestamp || result.afterTimestamp;
      if (timestamp) {
        const date = new Date(timestamp).toLocaleString();
        this.doc.fontSize(12)
          .fillColor('#8b949e')
          .text(`Captured: ${date}`, this.margin, 70);
      }

      // Add screenshots
      await this.addScreenshotImages(result, dataFile.metadata.mode);
    }
  }

  private async addScreenshotImages(result: any, mode: string): Promise<void> {
    const startY = 160;
    const imageGap = 30; // Gap between images

    if (mode === 'single' && result.singlePath) {
      // Single screenshot - centered
      const centeredX = this.margin + (this.contentWidth - this.imageWidth) / 2;
      await this.addImage(result.singlePath, centeredX, startY);
    } else if (mode === 'before-after' && result.beforePath && result.afterPath) {
      // Calculate centered positions for before/after images
      const totalImageWidth = (this.imageWidth * 2) + imageGap;
      const startX = (this.pageWidth - totalImageWidth) / 2;

      // Before image (left side, centered)
      this.doc.fillColor('#f0f6fc')
        .fontSize(14)
        .font('Helvetica-Bold')
        .text('Before', startX, startY - 25);

      await this.addImage(result.beforePath, startX, startY);

      // After image (right side, centered)
      const afterX = startX + this.imageWidth + imageGap;
      this.doc.fillColor('#f0f6fc')
        .fontSize(14)
        .font('Helvetica-Bold')
        .text('After', afterX, startY - 25);

      await this.addImage(result.afterPath, afterX, startY);
    }
  }

  private async addImage(imagePath: string, x: number, y: number): Promise<void> {
    try {
      if (fs.existsSync(imagePath)) {
        // Add subtle border effect
        this.doc.rect(x - 1, y - 1, this.imageWidth + 2, this.imageHeight + 2)
          .fill('#30363d');

        // Add main image container
        this.doc.rect(x, y, this.imageWidth, this.imageHeight)
          .fill('#21262d');

        // Add the image with better centering
        this.doc.image(imagePath, x, y, {
          width: this.imageWidth,
          height: this.imageHeight,
          fit: [this.imageWidth, this.imageHeight],
          align: 'center',
          valign: 'center'
        });
      } else {
        // Image not found - add placeholder with theme colors
        this.doc.rect(x, y, this.imageWidth, this.imageHeight)
          .stroke('#30363d')
          .fillColor('#21262d')
          .fill();

        this.doc.fillColor('#8b949e')
          .fontSize(12)
          .text('Image not found', x + this.imageWidth / 2 - 40, y + this.imageHeight / 2 - 10);
      }
    } catch (error) {
      console.warn(`Warning: Could not add image ${imagePath}:`, error);

      // Add error placeholder with theme colors
      this.doc.rect(x, y, this.imageWidth, this.imageHeight)
        .stroke('#f85149')
        .fillColor('#21262d')
        .fill();

      this.doc.fillColor('#f85149')
        .fontSize(10)
        .text('Error loading image', x + this.imageWidth / 2 - 40, y + this.imageHeight / 2 - 10);
    }
  }

  private addSummaryPage(dataFile: DataFile): void {
    this.doc.addPage();

    // Dark background matching theme
    this.doc.rect(0, 0, this.pageWidth, this.pageHeight)
      .fill('#0d1117');

    // Title
    this.doc.fillColor('#f0f6fc')
      .fontSize(28)
      .font('Helvetica-Bold')
      .text('Summary', this.margin, 60);

    let y = 120;
    const lineHeight = 22;

    // Statistics section
    this.doc.fontSize(16)
      .fillColor('#58a6ff')
      .text('Statistics', this.margin, y);

    y += 35;
    this.doc.fontSize(14)
      .fillColor('#8b949e')
      .text(`Total URLs processed: `, this.margin, y);
    this.doc.fillColor('#f0f6fc')
      .text(`${dataFile.metadata.totalUrls}`, this.margin + 180, y);

    y += lineHeight;
    this.doc.fillColor('#8b949e')
      .text(`Successful screenshots: `, this.margin, y);
    this.doc.fillColor('#3fb950')
      .text(`${dataFile.metadata.successCount}`, this.margin + 180, y);

    y += lineHeight;
    this.doc.fillColor('#8b949e')
      .text(`Failed screenshots: `, this.margin, y);
    this.doc.fillColor('#f85149')
      .text(`${dataFile.metadata.errorCount}`, this.margin + 180, y);

    // Configuration section
    y += 50;
    this.doc.fontSize(16)
      .fillColor('#58a6ff')
      .text('Configuration', this.margin, y);

    y += 35;
    this.doc.fontSize(14)
      .fillColor('#8b949e')
      .text(`Viewport: `, this.margin, y);
    this.doc.fillColor('#f0f6fc')
      .text(`${dataFile.metadata.options.width}x${dataFile.metadata.options.height}`, this.margin + 100, y);

    y += lineHeight;
    this.doc.fillColor('#8b949e')
      .text(`Wait strategy: `, this.margin, y);
    this.doc.fillColor('#f0f6fc')
      .text(`${dataFile.metadata.options.waitStrategy}`, this.margin + 110, y);

    y += lineHeight;
    this.doc.fillColor('#8b949e')
      .text(`Timeout: `, this.margin, y);
    this.doc.fillColor('#f0f6fc')
      .text(`${dataFile.metadata.options.timeout}ms`, this.margin + 90, y);

    y += lineHeight;
    this.doc.fillColor('#8b949e')
      .text(`Max retries: `, this.margin, y);
    this.doc.fillColor('#f0f6fc')
      .text(`${dataFile.metadata.options.maxRetries}`, this.margin + 100, y);

    // Timing information for before/after mode
    if (dataFile.metadata.beforePhase && dataFile.metadata.afterPhase) {
      y += 50;
      this.doc.fontSize(16)
        .fillColor('#58a6ff')
        .text('Timing', this.margin, y);

      y += 35;
      this.doc.fontSize(14)
        .fillColor('#8b949e')
        .text(`Before phase: `, this.margin, y);
      this.doc.fillColor('#f0f6fc')
        .text(`${dataFile.metadata.beforePhase.duration}`, this.margin + 110, y);

      y += lineHeight;
      this.doc.fillColor('#8b949e')
        .text(`After phase: `, this.margin, y);
      this.doc.fillColor('#f0f6fc')
        .text(`${dataFile.metadata.afterPhase.duration}`, this.margin + 105, y);
    }

    // Footer - positioned dynamically below content with safe spacing
    const footerY = Math.min(y + 60, this.pageHeight - 30);
    this.doc.fontSize(12)
      .fillColor('#6e7681')
      .text('Report generated by Screenshot CLI', 0, footerY, {
        width: this.pageWidth,
        align: 'center'
      });
  }

  private truncateUrl(url: string, maxLength: number = 60): string {
    if (url.length <= maxLength) return url;

    const start = url.substring(0, 20);
    const end = url.substring(url.length - 30);
    return `${start}...${end}`;
  }
} 